--- a/electron/renderer/src/App.tsx
+++ b/electron/renderer/src/App.tsx
@@ -313,7 +313,6 @@
       // First, process all WebSocket devices
       wsDevices.forEach(d => {
         const existing = prev.find(p => p.id === d.id);
-        const wasUserDisconnected = userDisconnectedDevices.has(d.id);

         // Calculate signal strength from RSSI
         let signalStrength: 1 | 2 | 3 | 4 = 1;
@@ -323,20 +322,7 @@
         else signalStrength = 1;

         if (existing) {
-          console.log(`ðŸ” Processing existing device ${d.name}: backend state=${d.state}, UI state=${existing.connectionStatus}, isReconnecting=${d.isReconnecting}, wasUserDisconnected=${wasUserDisconnected}`);
-
-          // If device was manually disconnected by user, it should have been removed from backend
-          // If it somehow reconnects, log a warning (shouldn't happen with removeDevice)
-          if (wasUserDisconnected && (d.state === 'connected' || d.state === 'streaming')) {
-            console.warn(`âš ï¸ User-disconnected device ${d.name} reconnected unexpectedly - this should not happen`);
-            // Device was removed from backend but is reconnecting somehow
-            // Keep it disconnected in UI but don't fight the backend
-            merged.set(d.id, {
-              ...existing,
-              signalStrength,
-              connectionStatus: 'disconnected' as const,
-              isReconnecting: false,
-              reconnectAttempts: 0,
-            });
-            return;
-          }
+          console.log(`ðŸ” Processing existing device ${d.name}: backend state=${d.state}, UI state=${existing.connectionStatus}, isReconnecting=${d.isReconnecting}`);

           // WebSocket confirms connection - override local state
@@ -372,8 +358,7 @@
             // Check if device is actively reconnecting
             const isActivelyReconnecting = d.isReconnecting ?? false;

-            // If we're in a connecting transition (and NOT user-disconnected), keep it
-            if (!wasUserDisconnected && (existing.connectionStatus === 'connecting' || existing.connectionStatus === 'synchronizing')) {
+            // If we're in a connecting transition, keep it
+            if (existing.connectionStatus === 'connecting' || existing.connectionStatus === 'synchronizing') {
               merged.set(d.id, {
                 ...existing,
@@ -425,14 +410,6 @@
           // New device - map WebSocket state to UI state
           let connectionStatus: "connected" | "disconnected" | "disabled" | "connecting" | "synchronizing" = 'disconnected';
           if (d.state === 'connected' || d.state === 'streaming') {
-            // If this is a new device that's already connected, but user previously disconnected it,
-            // it shouldn't be reconnecting (since we used removeDevice)
-            if (wasUserDisconnected) {
-              console.warn(`âš ï¸ User-disconnected device ${d.name} appeared as connected - this should not happen`);
-              connectionStatus = 'disconnected';
-            } else {
-              connectionStatus = 'connected';
-            }
+            connectionStatus = 'connected';
           } else if (d.state === 'error') {
             connectionStatus = 'disabled';
@@ -457,7 +434,6 @@
       // Second, keep any connected/connecting devices not in the scan
-      // (but NOT if they were user-disconnected)
       prev.forEach(device => {
         if (!merged.has(device.id) &&
             (device.connectionStatus === 'connected' ||
@@ -470,7 +446,7 @@

       return Array.from(merged.values());
     });
-  }, [wsDevices, userDisconnectedDevices, isStreaming])
+  }, [wsDevices, isStreaming])

   // Initialize device order when new devices are discovered (use ref to track)
   const lastDeviceIdsRef = useRef<Set<string>>(new Set());
@@ -543,9 +519,6 @@
     // Don't allow re-connecting if already connected or connecting
     if (device.connectionStatus === "connected" || device.connectionStatus === "connecting") {
       if (device.connectionStatus === "connected") {
-        // User manually disconnecting - use removeDevice to stop backend auto-reconnect
-        console.log(`ðŸ”´ User manually disconnected device: ${device.name} - removing from managed devices`)
-        setUserDisconnectedDevices((prev) => new Set(prev).add(device.id))
-
         // CRITICAL: If streaming is active, stop the recording session first
         // Otherwise backend will keep trying to stream from devices
@@ -583,11 +556,6 @@

     // Only proceed if disconnected
     if (device.connectionStatus === "disconnected") {
-      // User manually connecting - remove from userDisconnectedDevices set
-      console.log(`ðŸŸ¢ User manually connected device: ${device.name}`)
-      setUserDisconnectedDevices((prev) => {
-        const next = new Set(prev)
-        next.delete(device.id)
-        return next
-      })
-
       // Start WebSocket connect in background
@@ -610,10 +578,6 @@
   const handleConnectAll = () => {
     if (isLocating || sortedDevices.some((d) => d.connectionStatus === "synchronizing")) return

-    // User wants to connect all - clear the userDisconnectedDevices set
-    console.log(`ðŸŸ¢ User manually connecting all devices - clearing disconnect list`)
-    setUserDisconnectedDevices(new Set())
-
     // Call WebSocket connect all in background
     connectAllDevices()

@@ -630,11 +594,6 @@
   const handleDisconnectAll = () => {
     if (isLocating || sortedDevices.some((d) => d.connectionStatus === "synchronizing")) return

-    // User manually disconnecting all - add all device IDs to userDisconnectedDevices set
-    const allDeviceIds = sortedDevices.map(d => d.id)
-    console.log(`ðŸ”´ User manually disconnected all devices: ${allDeviceIds.length} devices - removing from managed devices`)
-    setUserDisconnectedDevices(new Set(allDeviceIds))
-
     // CRITICAL: If streaming is active, stop the recording session first
     // Otherwise backend will keep trying to stream from devices
@@ -1321,11 +1280,6 @@
                         try {
                           const result = await wsRemoveDevice(device.id);
                           if (result.success) {
                             console.log(`âœ… Device ${device.id} removed successfully`);
-                            // Remove from userDisconnectedDevices set
-                            setUserDisconnectedDevices((prev) => {
-                              const next = new Set(prev)
-                              next.delete(device.id)
-                              return next
-                            })
                             // Optimistically remove from local state
                             setDevices(prev => prev.filter(d => d.id !== device.id));
                           } else {
